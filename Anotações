JAVA DESENVOLVIMENTO WEB
-----------------------------------------------------------------------------------------------------------
PROFESSOR: LEONARDO -> Coordenador, arquiteto de solução
EMAIL: leonardo.silva@caelum.com

*PARA REVISAR:
	-Recriar o ConnectionFactory();
	-Recriar o Teste da conexão();
	-Recriar as classes Contato + ContadoDAO (inserir e listar)
	-Criar o teste para classe DAO;
	-Realizar conexão com TOMCAT
	-Criar 1º projeto EE;
	-Criar Servlet que recebe de um formulário dados e realizar a inserção;
	-Criar uma pagina JSP para listar dados e criar as exceçes no web.xml;

*DICAS LEONARDO
	-Relacionamentos com pessoas da área;
	-Criar linkedin, extremamente importante;
	-FOCO, fds vai estudar!
	-Importando uma API -> utilizar o repositorio do Maven para procurar a API necessria -> baixa o JAR e adicionar ele através do build Path


*ESTUDAR:
	-Banco de dados nao relacional, como MongoDB (os relacionais serao o MySql, SQLServer)
	-CALENDAR -> verificar, utilizado para funçoes de java
	-Estudar List
	-OMniFaces (templates)

*ENTENDENDO DATE P/ MYSQL
	Calendar vem do Util, o Date vem do Util e o Date vem do sql;
	- Comece com um Calendar data = new Calendar.getInstance(); //Deste modo estará iniciando declarando "HOJE"
	- Date dateUtil = new Date();
	
	- Em caso de receber a data atravês de um formulario:
		
		String dataTexto = req.getParameter("dataNascimento");
		Calendar cal = Calendar.getInstance();

		try {
			Date date = new SimpleDateFormat("dd/MM/yyyy").parse(dataTexto);
			cal.setTime(date);
		} catch (ParseException e1) {
			e1.printStackTrace();
		}
		
		Outro exemplo quando se vem direto de um Calendar
		<td><%=new SimpleDateFormat("dd/MM/yyyy").format(c1.getDataNascimento().getTime())%></td>

		- Dado uma String -> o/ Date -> utilizase (parse)

-----------------------------------------------------------------------------------------------------------
CAPITULO 2 - BANCO DE DADOS

*Para conectar a um banco, temos algumas premissas:
  -Driver (cada banco de dados tem um);
    -A comunicação é feita via TCP/IP (igual a acessar a um roteador, colocando IP:PORTA)

*JDBC: Java DataBase Connectivity -> É O PADRÃO JAVA, todo driver deve seguir este padrão
  - O JDBC necessita de uma interface, para que aja um padrão dentre DRIVER e o JAVA;
  - PREMISSAS PARA O JDBC:
    - ip
    - porta
    - usuario
    - senha
  Em resumo, -> "jdbc:mysql://ip/nome_do_banco","usuario","senha"

RESUMINDO:
*USUARIO ---> JAVA ----> Objeto Connection ----> DriverManager ---> JDBC + BD (TipoDeBanco + ip + porta + usuario + senha)

*A partir do momento que temos uma conexão feita, criaremos a class que FABRICA CONEXOES! de forma que todas as outras classes chamem ela!

*FABRICA DE CONEXOES (convencionada)

//Class fabrica de conexão
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class ConnectionFactory {

	public Connection getConnection() {
		try {
			return DriverManager.getConnection("jdbc:mysql://localhost/fj21", "root","");
		} catch (SQLException e){		
			throw new RuntimeException(e);
		}
	}

}


*Para as classes que irão chamar esta conexao, sera necessario apenas utilizar este objeto

//Class pesquisa
import java.sql.Connection;
import java.sql.SQLException;
import br.com.caelum.jdbc.ConnectionFactory;

public class TesteConexao {
	public static void main (String[] args) throws SQLException {
		ConnectionFactory con = new ConnectionFactory();
		Connection conexao = con.getConnection();
		System.out.println("conectado");
		
		conexao.close();
	}
}



*JAVBEANS? O javabeans é quando uma class que possui atributos (getters and setters and construct default)

*SQL INjection? Hackers? Para resolver o problema de inserssao de dados, foi criado o PrepareStatement, de forma que ele impossibilita
que codigo SQL derrubem a base.


*INSERIR (INSERT INTO)

- Antes de começar devemos criar nosso objeto, no caso "Contatos", com os atributos privados que estara no pacote "modelo"
- Criamos o pacote "dao" e pacote "testes"

- CODIGO PARA INSERÇÃO DE DADOS UTILIZANDO PREPARESTATEMENT

	package br.com.caelum.jdbc.teste;
	import java.sql.Connection;
	import java.sql.PreparedStatement;
	import java.sql.SQLException;
	import java.util.Calendar;


	import br.com.caelum.jdbc.ConnectionFactory;

	public class InserirJDBC {

		public static void main(String[] args) throws SQLException {
			Connection con = new ConnectionFactory().getConnection();

			String sql = "insert into contatos (nome,email,endereco,dataNascimento) value (?,?,?,?)";
			PreparedStatement stmr = con.prepareStatement(sql);
			stmr.setString(1, "teste");
			stmr.setString(2, "teste");
			stmr.setString(3, "teste");
			stmr.setDate(4, new java.sql.Date(Calendar.getInstance().getTimeInMillis()));
			stmr.execute();

			stmr.close();
			System.out.println("Dados inseridos");

			con.close();
		}
	}


- CODIGO PARA INSERÇÃO DE DADOS UTILIZANDO DAO

*Para evitar que se repitam codigos para fazer o CRUD, o ideal e se criar uma class do SQL
	- Por exemplo, public class ContatosSQL, que irá receber todas as consultas

	-PACKAGE br.com.caelum.dao
	
	public class ContatoDAO {
		private Connection con = new ConnectionFactory().getConnection();
		private PreparedStatement stmt;

		public void adicionar(Contato contato) throws SQLException {
			String sql = "INSERT INTO contatos (nome,email,endereco,dataNascimento) values(?,?,?,?)";

			try {
				stmt = con.prepareStatement(sql);
				stmt.setString(1, contato.getNome());
				stmt.setString(2, contato.getEmail());
				stmt.setString(3, contato.getEndereco());
				stmt.setDate(4, new Date(contato.getDataNasc().getTimeInMillis()));
				stmt.execute();

				stmt.close();
				con.close();
			} catch (SQLException e) {
				throw new RuntimeException(e);
			}
		}
	}
	
*LISTAR (SELECT) - para listar é necessrio usar um List<objeto>
	-Por padrão, podemo seguir as premissas abaixo:
		- Crie uma Lista vazia;
		- Declare sua query;
		- Prepare a query com o PrepareStatement
		- Construa o ResultSet com o stmt.executeQuery
		- Faça um laço (while) -> neste laço iremos criar um objeto e percorrer cada coluna da tabela
			-Dentro do while, crie um objeto [Contato c1 = new Contato]
			-Percorra cada coluna da tabela, com rs.getString (em caso de String)
			-Adicione a lista (com Lista.add(c1))
		-Retorne a Lista criada no laço;

	*CODIGO PARA LISTAR
	public List<Contato> getLista() throws SQLException {
			List<Contato> lista = new ArrayList<Contato>();
			String sql = "SELECT * FROM contatos";
			stmt = con.prepareStatement(sql);
			
			ResultSet rs = stmt.executeQuery();
			while (rs.next()) {
				Contato c1 = new Contato();
				c1.setNome(rs.getString("nome"));
				c1.setEmail(rs.getString("email"));
				c1.setEndereco(rs.getString("endereco"));

				Calendar dataCalendar = Calendar.getInstance();				
				dataCalendar.setTime(rs.getDate("dataNascimento"));	
				c1.setDataNasc(dataCalendar);
				
				lista.add(c1);
			}
			
			return lista;
	}
	
	*CODIGO PARA EXIBIR A LISTA
	public static void main(String[] args) throws SQLException {
		String pattern = "dd-MM-yyyy";
		SimpleDateFormat simpleDateFormat = new SimpleDateFormat(pattern);
		
		Contato contato = new Contato();		
		ContatoDao dao = new ContatoDao();
		
		List<Contato> lista = dao.getLista();
		for(Contato con : lista) {
			System.out.println("---------------------------------");
			System.out.println("Nome = " + contato.getNome());
			System.out.println("Email = " + contato.getEmail());
			System.out.println("Endereco = " + contato.getEndereco());
			System.out.println("Data = " + contato.getDataNasc());
			System.out.println("---------------------------------");
		}	
	}

CAPITLO 3 - JAVA EE
- O Java EE e uma especificacao, um grande PDF padronizando servidores e etc.

*JSF (Java Server Faces) -> [voltado ao desktop, app de mercados]
*JSP (Java Server Pages) -> [voltado a paginas web]
*EJB (Enterprise Javabeans Components) -> Voltado a container, gerenciamento (aplicaçoes antigas)
*JPA (Java Persistence API) -> Uma persistencia no PrepareStatement e um JPA
*JAX-WS (Java API for XML Web Services)
*JAAS (Java autentication and Authorization Service) -> API de segurança java -> SpringSecurity
*JTA (Java Transaction API) -> Serve para barrar transações (Foi usar o cartão e deu erro, JTA ira barrar)
*JMS (Java Message Service) -> Utilizado para passar mensagens para outra aplicações
*JNDI (Java Naming and Directory Interface) -> Para diretorios, de forma que eu acesse um outro método DAO de outra aplicação

*SERÃO APRENDIDOS NO CURSO
	- JSP, JPA, JDBC, EJB, JTA
	
*Servidores de Aplicaço vs SERVLET Container -> a principal diferença  que o SERVLET possui menos especificações do que um servidor de aplicação	

*SERVIDORES DE APLICAÇÃO - MAIS CONHECIDOS:
	- GlassFish (oracle) JAVA EE 7
	- RedHat/JBoss JAVA EE 6
	- WEBLOGIC (Oracle) JAVA EE 6
	- WEBSPHERE (IBM) JAVA EE 6
	
*SERVLET CONTAINER - MAIS CONHECIDOS:
	- TOMCAT
	- WILDFLY
	- JETTY

*PRINCIPAIS ESPECIFICAÇES AGRUPADAS PELO SERVLET CONTAINER:
	-Servlet
	-JSP
	-JSTL
	-JSF

*UTILIZANDO O TOMCAT
	- O Eclipse possui um plugin para utilizar o TomCat -> chamado WTP
	- Para mapear um servidor no Eclipse, é necessario alterar a perspectiva do Eclipse para JAVA EE
		- Ir ate Servers -> ir para Apache -> Selecionar o TomCat X.X.X -> finish
		
*COMEÇANDO UM PROJETO EE!!
	- CTRL + N -> dynamic web project
	- Verifique se o projeto puxou o tomcat
	- next, next, marque a opção Generate web.xml deployment
	- Clique com direito na aba servers (tomcat) -> add and remove -> selecione o projeto
	
*ENTENDENDO AS PASTAS CRIADAS
	- WebContent -> ficará todos os arquivos acessiveis (bemvindo.html)
		- WEB-INF/web.xml -> define o nome do projeto e a lista de arquivos a serem acessados
		- lib -> ficarao os arquivos JAR

*PÁGINA DINMICA E PAGINA ESTATICA
	- Em Java para se criar uma página dinamica (pagina que se altera conforme pedido do usuario), é necessrio criar uma classe
		capaz de gerar um conteúdo HTML ->SERVLET e responsavel para realizar esta função
		
	- Para criar a Servlet:
		- Criamos um package br.com.caelum.servlet
		- Criamos a classe minhaClasse
		- extendemos o HttpServlet
		- digitamos service e ctrl + space
		- chamamos o escritor
		
	
		public class OiMundo extends HttpServlet{

			@Override
			protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
				PrintWriter out = response.getWriter();

				out.println("<html>");
				out.println("<h1>Oi mundo Servlet! </h1>");Banco de dados nao relacional, como MongoDB (os relacionais serao o MySql, SQLServer)
				out.println("</html>");

			}
		}

	*1º METODO
	- O <servlet> sera informado no web.xml
	
		  <servlet>
			<servlet-name>primeiraServlet</servlet-name>
			<servlet-class>br.com.caelum.servlet.OiMundo</servlet-class>
		  </servlet>

	- O <servlet-mapping> informara qual a class servlet e onde sera acessado na URL
		  <servlet-mapping>
			<servlet-name>primeiraServlet</servlet-name>
			<url-pattern>/oi/</url-pattern>
		  </servlet-mapping>
		  
	*2º METODO
	- Implementamos a servlet diretamente na class OiMundo, utilizando @webServlet
	
	@WebServlet ("/oi")
	public class OiMundo extends HttpServlet{

			@Override
			protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
				PrintWriter out = response.getWriter();

				out.println("<html>");
				out.println("<h1>Oi mundo Servlet! </h1>");
				out.println("</html>");

			}
		}

*TRABALHANDO COM FORMULARIOS
	- Quando for criado um formulrio em HTML, o <form action = "testandoServlet"> é quem ira tratar os dados, ou seja, nosso formulario
		"adiciona-contato.html" terá o form e minha servlet chamara "public class AdicionaContato"
	- Na servlet devemos informar @WebServlet ("/testandoServlet")data = Calendar
	- Para pegar os dados do formulario, devemos pegar de nosso "req"
		- Contato c1 = new Contato();
		- c1.setNome(req.getParameter("nome"));
	- Para escrever uma pagina HTML, utilizamos o PrintWriter out = resp.getWriter();
		-out.println("<html>");
		- out.println("<body>");
		- out.println("Usuario" + c1.getNome() + "Cadastrado");
		- out.println("</body>");data = Calendar
		- out.println("</html>");
	
	
*Inserindo dados atraves da servlet
package br.com.caelum.agenda.servlet;

import java.io.IOException;
import java.io.PrintWriter;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import br.com.caelum.agenda.dao.ContatoDao;
import br.com.caelum.agenda.modelo.Contato;

@WebServlet("/adicionaContato")
public class AdicionaContatoServlet extends HttpServlet{

	@Override
	protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		
		Contato c1 = new Contato();
		c1.setNome(req.getParameter("nome"));
		c1.setEmail(req.getParameter("email"));
		c1.setEndereco(req.getParameter("endereco"));

		String dataTexto = req.getParameter("dataNascimento");
		Calendar cal = Calendar.getInstance();

		try {
			Date date = new SimpleDateFormat("dd/MM/yyyy").parse(dataTexto);
			cal.setTime(date);
		} catch (ParseException e1) {
			e1.printStackTrace();
		}

		c1.setDataNascimento(cal);
		
		ContatoDao dao = new ContatoDao();
		dao.adiciona(c1);
		
		PrintWriter out = resp.getWriter();
		
		out.println("<html>");
		out.println("<body>");
		out.println("Usuario" + c1.getNome() + "Cadastrado");
		out.println("</body>");
		out.println("</html>");
	}
}


*HTTP -> GET/POST
	- Get -> exibe no navegador os dados passados pelo formulrio
	
	
* CAPITLO 6 - JSP
	- O JSP roda no Servidor
	- O JSP veio para trabalhar o HTML e JAVA Juntos, de modo que no precise jogar um HTML pela servlet
	- Scriptlet é a tag <%
	- Como?
		<html>
			<%
				Sysout("escrevendo no console");	
			%>
		</html>
	- O codigo acima  chamado SCriptLet, utilizado para pequenos blocos de cdigo
	
	- Para exibir na tela via JSP:
		1º metodo <%=c1.getNome()%> -> necessrio utilizar o '='
		2º metodo <% out.println(c1.getNome())%> -> atravês do out.println do resp
	- Listando itens
	
		<%@page import="br.com.caelum.agenda.dao.ContatoDao"%>
		<%@page import="br.com.caelum.agenda.modelo.Contato"%>
		<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
		
		<!DOCTYPE html>
		<html>
		<head>
		<meta charset="UTF-8">
		<title>Listando dados com scriptlet</title>
		</head>
		<body>

			<%
				ContatoDao dao = new ContatoDao();
				List<Contato> lista = dao.getLista();
			%>

			<table>
				<tr>
					<th>Nome</th>
					<th>Email</th>
					<th>Endereco</th>
					<th>Data nascimento</th>
				</tr>
				<%
					for (Contato c1 : lista) {
				%>

				<tr>
					<td><%=c1.getNome()%></td>
					<td><%=c1.getEmail()%></td>
					<td><%=c1.getEndereco()%></td>
					<td><%=new SimpleDateFormat("dd/MM/yyyy").format(c1.getDataNascimento().getTime())%></td>
				</tr>
				<%
					}
				%>
			</table>
		</body>
		</html>

* CAPITULO 7 - CONTINUANDO JSP (TAGLIBS) -> JSTL -> ${} -> Expression Language
	- A taglibs vem para fazer uma linguagem só (HTML + JAVA), sem precisar escrever em duas linguagens diferentes;
	- TAGS:
		-CORE
			<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
		-FMT
			<%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt"%>
	
	- ANTES (JSP)
	<html>
		<@pages import="br.com.caelum.agenda.dao">
		<% Contatodao dao = new Contatodao() %>

	- DEPOIS (JSTL)
	<html>
		<jsp: useBean id="dao" class="br.com.caelum.agenda.dao">
	
	- ANTES (JSP)
		<table>
		<%  for (Contato c1 : lista) {	%>
			<tr>
			 <td><%=c1.getNome()%></td>
			 <td><%=c1.getEmail()%></td>
			 <td><%=c1.getEndereco()%></td>
			 <td><%=new SimpleDateFormat("dd/MM/yyyy").format(c1.getDataNascimento().getTime())%></td>
			</tr>
		<% } %>
		</table>
		
	- DEPOIS (JSTL)
		<table>
		   <c:forEach var="contato" items="${dao.lista}" varStatus="id">
			<tr bgcolor="#${id.count % 2 == 1 ? 'ffffff' : 'eeeeee' }"
				align="center">

				<td>${id.count}</td>
				<td>${contato.nome}</td>
				<td>${contato.email}</td>
				<td>${contato.endereco}</td>
				<td><fmt:formatDate value="${contato.dataNascimento.time}" pattern="dd/MM/yyyy"/>					</td>
			</tr>
		   </c:forEach>
		</table>
	
	
	-TAGS IMPORTANTES
		if:
		  <c:if test"Sua condicional">
			exemplo:
			<c: if test"${not empty contato.email}">
				<td>${contato.email} </td>
		        </c:if>
		
		when:
		  <c:while test="${not empty contato.email}">
		  	<a href="mailto:${contato.email}"> ${contato.email} </a>
		  </c:while>
		  
		switch:
		  <c:choose>
		      <c:otherwise>
		      </c:otherwise>
		  </c:choose>
				exemplo:
				<c:choose>
					<c:while test="${not empty contato.email}">
		  				<a href="mailto:${contato.email}"> ${contato.email} </a>
		  			</c:while>
				        <c:otherwise>
						E-mail não informado
				        </c:otherwise>
				 </c:choose>
	
		import: (importar rodapé)
		  <c:import url="rodape.jsp">

*CAPITLO 8 - TAGFILES (criando a propria Expression Language)
	
	
	
	
	
	
	
	
	
	
	
	
	
	
