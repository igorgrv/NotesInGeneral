JAVA DESENVOLVIMENTO WEB
-----------------------------------------------------------------------------------------------------------
PROFESSOR: LEONARDO -> Coordenador, arquiteto de solução
EMAIL: leonardo.silva@caelum.com

DICAS LEONARDO
*Relacionamentos com pessoas da área;
*Criar linkedin, extremamente importante;
*FOCO, fds vai estudar!
*Importando uma API -> utilizar o repositorio do Maven para procurar a API necessria -> baixa o JAR e adicionar ele através do build Path

*ENTENDENDO DATE P/ MYSQL
	Calendar vem do Util, o Date vem do Util e o Date vem do sql;
	- Comece com um Calendar data = new Calendar.getInstance(); //Deste modo estará iniciando declarando "HOJE"
	- Date dateUtil = new Date();

ESTUDAR:
*Banco de dados nao relacional, como MongoDB (os relacionais serao o MySql, SQLServer)
*CALENDAR -> verificar, utilizado para funçoes de java
*Estudar List
*OMniFaces (templates)
-----------------------------------------------------------------------------------------------------------
CAPITULO 2 - BANCO DE DADOS

*Para conectar a um banco, temos algumas premissas:
  -Driver (cada banco de dados tem um);
    -A comunicação é feita via TCP/IP (igual a acessar a um roteador, colocando IP:PORTA)

*JDBC: Java DataBase Connectivity -> É O PADRÃO JAVA, todo driver deve seguir este padrão
  - O JDBC necessita de uma interface, para que aja um padrão dentre DRIVER e o JAVA;
  - PREMISSAS PARA O JDBC:
    - ip
    - porta
    - usuario
    - senha
  Em resumo, -> "jdbc:mysql://ip/nome_do_banco","usuario","senha"

RESUMINDO:
*USUARIO ---> JAVA ----> Objeto Connection ----> DriverManager ---> JDBC + BD (TipoDeBanco + ip + porta + usuario + senha)

*A partir do momento que temos uma conexão feita, criaremos a class que FABRICA CONEXOES! de forma que todas as outras classes chamem ela!

*FABRICA DE CONEXOES (convencionada)

//Class fabrica de conexão
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class ConnectionFactory {

	public Connection getConnection() {
		try {
			return DriverManager.getConnection("jdbc:mysql://localhost/fj21", "root","");
		} catch (SQLException e){
			throw new RuntimeException(e);
		}
	}

}


*Para as classes que irão chamar esta conexao, sera necessario apenas utilizar este objeto

//Class pesquisa
import java.sql.Connection;
import java.sql.SQLException;
import br.com.caelum.jdbc.ConnectionFactory;

public class TesteConexao {
	public static void main (String[] args) throws SQLException {
		ConnectionFactory con = new ConnectionFactory();
		Connection conexao = con.getConnection();
		System.out.println("conectado");
		
		conexao.close();
	}
}



*JAVBEANS? O javabeans é quando uma class que possui atributos (getters and setters and construct default)

*SQL INjection? Hackers? Para resolver o problema de inserssao de dados, foi criado o PrepareStatement, de forma que ele impossibilita
que codigo SQL derrubem a base.


*INSERIR (INSERT INTO)

- Antes de começar devemos criar nosso objeto, no caso "Contatos", com os atributos privados que estara no pacote "modelo"
- Criamos o pacote "dao" e pacote "testes"

- CODIGO PARA INSERÇÃO DE DADOS UTILIZANDO PREPARESTATEMENT

	package br.com.caelum.jdbc.teste;
	import java.sql.Connection;
	import java.sql.PreparedStatement;
	import java.sql.SQLException;
	import java.util.Calendar;


	import br.com.caelum.jdbc.ConnectionFactory;

	public class InserirJDBC {

		public static void main(String[] args) throws SQLException {
			Connection con = new ConnectionFactory().getConnection();

			String sql = "insert into contatos (nome,email,endereco,dataNascimento) value (?,?,?,?)";
			PreparedStatement stmr = con.prepareStatement(sql);
			stmr.setString(1, "teste");
			stmr.setString(2, "teste");
			stmr.setString(3, "teste");
			stmr.setDate(4, new java.sql.Date(Calendar.getInstance().getTimeInMillis()));
			stmr.execute();

			stmr.close();
			System.out.println("Dados inseridos");

			con.close();
		}
	}


- CODIGO PARA INSERÇÃO DE DADOS UTILIZANDO DAO

*Para evitar que se repitam codigos para fazer o CRUD, o ideal e se criar uma class do SQL
	- Por exemplo, public class ContatosSQL, que irá receber todas as consultas

	-PACKAGE br.com.caelum.dao
	
	public class ContatoDAO {
		private Connection con = new ConnectionFactory().getConnection();
		private PreparedStatement stmt;

		public void adicionar(Contato contato) throws SQLException {
			String sql = "INSERT INTO contatos (nome,email,endereco,dataNascimento) values(?,?,?,?)";

			try {
				stmt = con.prepareStatement(sql);
				stmt.setString(1, contato.getNome());
				stmt.setString(2, contato.getEmail());
				stmt.setString(3, contato.getEndereco());
				stmt.setDate(4, new Date(contato.getDataNasc().getTimeInMillis()));
				stmt.execute();

				stmt.close();
				con.close();
			} catch (SQLException e) {
				throw new RuntimeException(e);
			}
		}
	}
	
*LISTAR (SELECT) - para listar é necessrio usar um List<objeto>
	-Por padrão, podemo seguir as premissas abaixo:
		- Crie uma Lista vazia;
		- Declare sua query;
		- Prepare a query com o PrepareStatement
		- Construa o ResultSet com o stmt.executeQuery
		- Faça um laço (while) -> neste laço iremos criar um objeto e percorrer cada coluna da tabela
			-Dentro do while, crie um objeto [Contato c1 = new Contato]
			-Percorra cada coluna da tabela, com rs.getString (em caso de String)
			-Adicione a lista (com Lista.add(c1))
		-Retorne a Lista criada no laço;

	*CODIGO PARA LISTAR
	public List<Contato> getLista() throws SQLException {
			List<Contato> lista = new ArrayList<Contato>();
			String sql = "SELECT * FROM contatos";
			stmt = con.prepareStatement(sql);
			
			ResultSet rs = stmt.executeQuery();
			while (rs.next()) {
				Contato c1 = new Contato();
				c1.setNome(rs.getString("nome"));
				c1.setEmail(rs.getString("email"));
				c1.setEndereco(rs.getString("endereco"));

				Calendar dataCalendar = Calendar.getInstance();				
				dataCalendar.setTime(rs.getDate("dataNascimento"));	
				c1.setDataNasc(dataCalendar);
				
				lista.add(c1);
			}
			
			return lista;
	}
	
	*CODIGO PARA EXIBIR A LISTA
	public static void main(String[] args) throws SQLException {
		String pattern = "dd-MM-yyyy";
		SimpleDateFormat simpleDateFormat = new SimpleDateFormat(pattern);
		
		Contato contato = new Contato();		
		ContatoDao dao = new ContatoDao();
		
		List<Contato> lista = dao.getLista();
		for(Contato con : lista) {
			System.out.println("---------------------------------");
			System.out.println("Nome = " + contato.getNome());
			System.out.println("Email = " + contato.getEmail());
			System.out.println("Endereco = " + contato.getEndereco());
			System.out.println("Data = " + contato.getDataNasc());
			System.out.println("---------------------------------");
		}	
	}

CAPITLO 3 - JAVA EE
- O Java EE e uma especificacao, um grande PDF padronizando servidores e etc.

*JSF (Java Server Faces) -> [voltado ao desktop, app de mercados]
*JSP (Java Server Pages) -> [voltado a paginas web]
*EJB (Enterprise Javabeans Components) -> Voltado a container, gerenciamento (aplicaçoes antigas)
*JPA (Java Persistence API) -> Uma persistencia no PrepareStatement e um JPA
*JAX-WS (Java API for XML Web Services)
*JAAS (Java autentication and Authorization Service) -> API de segurança java -> SpringSecurity
*JTA (Java Transaction API) -> Serve para barrar transações (Foi usar o cartão e deu erro, JTA ira barrar)
*JMS (Java Message Service) -> Utilizado para passar mensagens para outra aplicações
*JNDI (Java Naming and Directory Interface) -> Para diretorios, de forma que eu acesse um outro método DAO de outra aplicação

*SERÃO APRENDIDOS NO CURSO
	- JSP, JPA, JDBC, EJB, JTA
	
*Servidores de Aplicaço vs SERVLET Container -> a principal diferença  que o SERVLET possui menos especificações do que um servidor de aplicação	

*SERVIDORES DE APLICAÇÃO - MAIS CONHECIDOS:
	- GlassFish (oracle) JAVA EE 7
	- RedHat/JBoss JAVA EE 6
	- WEBLOGIC (Oracle) JAVA EE 6
	- WEBSPHERE (IBM) JAVA EE 6
	
*SERVLET CONTAINER - MAIS CONHECIDOS:
	- TOMCAT
	- WILDFLY
	- JETTY

*PRINCIPAIS ESPECIFICAÇES AGRUPADAS PELO SERVLET CONTAINER:
	-Servlet
	-JSP
	-JSTL
	-JSF

*UTILIZANDO O TOMCAT
	- O Eclipse possui um plugin para utilizar o TomCat -> chamado WTP
	- Para mapear um servidor no Eclipse, é necessario alterar a perspectiva do Eclipse para JAVA EE
		- Ir ate Servers -> ir para Apache -> Selecionar o TomCat X.X.X -> finish
		
*COMEÇANDO UM PROJETO EE!!
	- CTRL + N -> dynamic web project
	- Verifique se o projeto puxou o tomcat
	- next, next, marque a opção Generate web.xml deployment
	- Clique com direito na aba servers (tomcat) -> add and remove -> selecione o projeto
	
*ENTENDENDO AS PASTAS CRIADAS
	- WebContent -> ficará todos os arquivos acessiveis (bemvindo.html)
		- WEB-INF/web.xml -> define o nome do projeto e a lista de arquivos a serem acessados
		- lib -> ficarao os arquivos JAR

*PÁGINA DINMICA E PAGINA ESTATICA
	- Em Java para se criar uma página dinamica (pagina que se altera conforme pedido do usuario), é necessrio criar uma classe
		capaz de gerar um conteúdo HTML ->SERVLET e responsavel para realizar esta função
		
	- Para criar a Servlet:
		- Criamos um package br.com.caelum.servlet
		- Criamos a classe minhaClasse
		- extendemos o HttpServlet
		- digitamos service e ctrl + space
		- chamamos o escritor
		
	
		public class OiMundo extends HttpServlet{

			@Override
			protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
				PrintWriter out = response.getWriter();

				out.println("<html>");
				out.println("<h1>Oi mundo Servlet! </h1>");
				out.println("</html>");

			}
		}

	*1º METODO
	- O <servlet> sera informado no web.xml
	
		  <servlet>
			<servlet-name>primeiraServlet</servlet-name>
			<servlet-class>br.com.caelum.servlet.OiMundo</servlet-class>
		  </servlet>

	- O <servlet-mapping> informara qual a class servlet e onde sera acessado na URL
		  <servlet-mapping>
			<servlet-name>primeiraServlet</servlet-name>
			<url-pattern>/oi/</url-pattern>
		  </servlet-mapping>
		  
	*2º METODO
	- Implementamos a servlet diretamente na class OiMundo, utilizando @webServlet
	
	@WebServlet ("/oi")
	public class OiMundo extends HttpServlet{

			@Override
			protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
				PrintWriter out = response.getWriter();

				out.println("<html>");
				out.println("<h1>Oi mundo Servlet! </h1>");
				out.println("</html>");

			}
		}

	


